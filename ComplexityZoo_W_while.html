<html> 
<head> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
h3,h4 {padding: 2px; border-style: double;}
</style> 
</head> 
<body><h3>Class Description</h3><h5><span class="mw-headline" id="WHILE:_While_programs_and_some_restrictions"><span id="while" style="color:red">WHILE</span>: While programs and some restrictions</span></h5><p>While is a theoretical programing language defined in <a href="https://complexityzoo.net/Zooref#jon98" class="mw-redirect" title="Zooref">[jon98]</a>, it is a way to define <a href="ComplexityZoo_W_Complexity_Zoo:P.23P.html">P</a> syntactically and a syntactic restriction of WHILE is exactly <a href="ComplexityZoo_W_Complexity_Zoo:L.23L.html">L</a>. The important point is that those two languages are powerful enough to simulate all of P (and L) and when we write a program in this language we never need to prove its time (space) complexity, since the language guarantees it!</p><p>In While, inputs are composed only of lists (in a lisp-way where a list is either an empty list or a pair of its first element and its tail) and the elements of the list and variables are only pointers to lists.</p><p>A program contains global variables and procedures.</p><ul><li>Every procedure is composed of a name, a list of argument and local variables and a list of commands. The procedure doesn't return any value, it only affects global variables.</li><li>The commands are: variable affectation, while loop, if/then/else and procedure call.</li><li>The empty list is considered as false and everything else as true, this is the only way to do while/if test.</li></ul><p>There are three function primitives: tail, head, and cons(h,t), which respectively give the first value of a list, the tail of the list and a list the first element of which is h and the rest of the list is t. We can also call defined procedures.</p><p>We can then define WHILE<sup>/cons-rec</sup> which is WHILE without the "cons" primitive and procedure call[#]. It is equivalent to L. The trick to do the computation in logspace is that without recursion we only need to save a fixed number of variables which are only pointers to part of the input, so they only take logspace. Since any logspace TM can avoid having a work tape by having a fixed number of reading head on his input, we can simulate logspace TM by using a variable for every reading head. (The binary string is coded as a list of () for 0 and (()) for 1, so equality can be checked trivially)</p><p>[#] in fact we only need to forbid recursive call, hence the name, but when we lose recursion we can assume there is no procedure call w.l.o.g, in fact in <a href="https://complexityzoo.net/Zooref#jon98" class="mw-redirect" title="Zooref">[jon98]</a> WHILE&#160;is first defined without procedure call and procedure are defined later, but this presentation may be more easy to understand and at least more general.</p><p>We can then also define WHILE<sup>rec/cons</sup> which is WHILE without "cons" primitive but with procedure calls, and hence recursion. It is equivalent to <a href="ComplexityZoo_W_Complexity_Zoo:P.23P.html">P</a>. The trick to do a computation of a WHILE<sup>rec/cons</sup> in P is to memoize the couple (global variables, input) when a procedure is called and the value of the globals variable when the procedure end, since we don't have cons, only a polynomial number of call will really be executed and we can detect loop.Simulating P in WHILE<sup>rec/cons</sup> is quite more subtle, P TM are equivalent to some counter machine wich can easily be simulated by WHILE programs with cons, and then we can simulate the cons thanks to the call stack. </p><h3>Linked From</h3><p>No class.</p></body> 
</html>